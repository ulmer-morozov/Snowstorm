module Snowstorm {
    "use strict";

    export class Colider {

        private body: Circle;
        private speed: Vector;
        private weight: number;

        private currentCollisions: Colider[];

        constructor(radius: number, x: number, y: number, weight: number = 1) {
            let position = new Point(x, y);

            this.currentCollisions = [];
            this.weight = weight;
            this.body = new Circle(radius, position);
            this.speed = new Vector();
        }

        punch(vx: number, vy: number): void {
            this.speed = new Vector(vx, vy);
        }

        enterFrame(): void {
            this.body.position.x += this.speed.x;
            this.body.position.y += this.speed.y;
        }

        private static calculateSpeed(speed: SpeedTuple, m1: number, m2: number): SpeedTuple {
            // if (m1 === 0) {
            //     return new SpeedTuple(speed.v1, -speed.v2);
            // }
            // if (m2 === 0) {
            //     return new SpeedTuple(-speed.v1, speed.v2);
            // }

            let v10 = speed.v1;
            let v20 = speed.v2;

            let sign = (-speed.v1 + speed.v2) / Math.abs(speed.v1 - speed.v2);

            let v1 = 2 * sign * m2 * v20 + (m1 - m2) * v10 / (m1 + m2);
            let v2 = 2 * m1 * v10 + sign * (m2 - m1) * v20 / (m1 + m2);

            // let v1Before_newOrigin = speed.v1 - speed.v2;
            //
            // let v1After_newOrigin = v1Before_newOrigin * (m1 - m2) / (m1 + m2);
            // let v2After_newOrigin = 2 * v1Before_newOrigin * m1 / (m1 + m2);
            //
            // let v1_initialOrigin = Math.round(v1After_newOrigin + speed.v2);
            // let v2_initialOrigin = Math.round(v2After_newOrigin + speed.v2);

            let resultSpeed = new SpeedTuple(v1, 0);
            return resultSpeed;
        }

        interact = (other: Colider): boolean => {
            let collisiionFinded = this.body.findCollision(other.body);
            let currentCollisionIndex = this.currentCollisions.indexOf(other);
            let isOldCollision = currentCollisionIndex != -1;

            if (!collisiionFinded) {
                if (isOldCollision) {
                    //удалим из списка коллизий
                    this.currentCollisions.splice(currentCollisionIndex, 1);
                    console.log("collision ended");
                }
                return false;
            }

            // if (isOldCollision)
            //     return false;

            let thisP = this.body.position;
            let otherP = other.body.position;

            let newSpeed1 = new Vector();
            let newSpeed2 = new Vector();

            newSpeed1.x = (this.speed.x * (this.weight - other.weight) + (2 * other.weight * other.speed.x)) / (this.weight + other.weight);
            newSpeed1.y = (this.speed.y * (this.weight - other.weight) + (2 * other.weight * other.speed.y)) / (this.weight + other.weight);

            newSpeed2.x = (other.speed.x * (other.weight - this.weight) + (2 * this.weight * this.speed.x)) / (this.weight + other.weight);
            newSpeed2.y = (other.speed.y * (other.weight - this.weight) + (2 * this.weight * this.speed.y)) / (this.weight + other.weight);

            this.speed.x = newSpeed1.x;
            this.speed.y = newSpeed1.y;

            other.speed.x = newSpeed2.x;
            other.speed.y = newSpeed2.y;

            this.body.position.x = this.body.position.x + this.speed.x;
            this.body.position.y = this.body.position.y + this.speed.y;

            other.body.position.x = other.body.position.x + other.speed.x;
            other.body.position.y = other.body.position.y + other.speed.y;

            this.currentCollisions.push(other);
            console.log("collisiion Finded");

            return true;
        }

    }
}
